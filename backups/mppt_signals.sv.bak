module mppt_and_signals (
	input logic clk,
	input logic [9:0] V_panel,
	input logic [9:0] I_panel,
	input logic [9:0] P_panel,
	input logic [9:0] V_cap,
	input logic [2:0] state_number,
	output logic cap_charged,
	output logic cap_over5,
	output logic PV_power_high,
	output logic pwr_low
);

logic [9:0] val;
logic [18:0] p_in;

always_ff @(posedge clk)
	begin
		
		if (up_flag)
			val <= val + 1;
		
		else if (down_flag)
			val <= val - 1;
	
		else
			val <= val;
			
	end
	
always_comb

   //control of encoded variable
	
	case (state_number)
	
		0: begin 
			   up_flag = 0;
				down_flag = 0;
			end
		
		1: begin
				if (V_panel > 450)
					up_flag = 0;
					down_flag = 1;
				
				else if (V_panel < 410)
					up_flag = 1;
					down_flag = 0;
				
				else
					up_flag = 0;
					down_flag = 0;
			
		2: begin
				if (V_panel > 450)
					up_flag = 0;
					down_flag = 1;
				
				else if (V_panel < 410)
					up_flag = 1;
					down_flag = 0;
				
				else
					up_flag = 0;
					down_flag = 0;
				
		3: begin
				if (V_panel > 450)
					up_flag = 0;
					down_flag = 1;
				
				else if (V_panel < 410)
					up_flag = 1;
					down_flag = 0;
				
				else
					up_flag = 0;
					down_flag = 0;
		
		4: begin
				up_flag = 0;
				down_flag = 0;
				val = 512;
		
	// look at this further	
	
	endcase
	
	//capcitor charged condition
	
	begin
		if(V_cap > 1600)
			cap_charged = 1;
		else
		   cap_charged = 0;
	end
	
	//capacitor over 5V check
	
	begin
		if(V_cap > 500)
			cap_over5 = 1;
		else
			cap_over5 = 0;
	end
	
	//checking input power of PV panels
	
	p_in = I_panel * V_panel;
	
	begin
		if(p_in > 300)
			PV_power_high = 1;
		else
			PV_power_high = 0;
	end
	
	//checking overall power availability
	
	begin
		if(~PV_power_high)&&(~cap_over5)
			pwr_low = 1;
		else 
			pwr_low = 0;
	end
	
endmodule
 